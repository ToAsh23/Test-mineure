# -*- coding: utf-8 -*-
"""Diabete.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UrDo0qInwwRhZmBH0O2BK51tKp4lGCbW
"""

import pandas as pd
import numpy as np
from google.colab import drive
drive.mount('/content/drive')

"""# Visualisation des données"""

file_path = '/content/diabetes_prediction_dataset.csv'
df = pd.read_csv(file_path)
df.head(10)

df.isnull().sum()

df_1 = df[df["smoking_history"] != "No Info"]
df.info()

df_1.describe()

df_1.isnull().sum()

"""# Nettoyage de la colonne genre et transformation en binaire"""

df_2 = df_1[df_1["gender"] != "Other"]
df_2

df_2['gender']  = df_2 ["gender"].map({'Female': 0, 'Male': 1})
df_2

df_3 = df_2
df_3

"""# Nettoyage des données de la colonne smokig_history et changement des str en int
Pour que les données puissent être traité
"""

valeurs_uniques_smoking = df_3['smoking_history'].unique()
valeurs_uniques_smoking

df_3['smoking_history']  = df_3 ["smoking_history"].map({'never': 0, 'not current': 1, 'former': 2, 'ever': 2, 'current': 3})
df_3

"""# Analyse Exploratoire EDA

# Visualisation graphique des données

## **Box plot**
"""

import matplotlib.pyplot as plt

colonnes_a_afficher = ['age', 'bmi', 'HbA1c_level', 'blood_glucose_level']  # Remplace par les noms de tes colonnes

for colonne in colonnes_a_afficher:
    df_3[[colonne]].boxplot()
    plt.title(f"Boxplot de la colonne {colonne}")
    plt.show()

import seaborn as sns
fig,ax = plt.subplots(2,2, figsize=(10,10))
sns.distplot(df_3.age, bins=20, ax=ax[0,0], color="red")
sns.distplot(df_3.bmi, bins=20, ax=ax[0,1], color="red")
sns.distplot(df_3.blood_glucose_level, bins=20, ax=ax[1,0], color="red")
sns.distplot(df_3.HbA1c_level, bins=20, ax=ax[1,1], color="red")

f,ax = plt.subplots(figsize=[10,5])
sns.heatmap(df_3.corr(), annot=True, fmt = '.2f', ax=ax, cmap='coolwarm')
ax.set_title("Correlation Matrix", fontsize=20)
plt.show()

#p = sns.pairplot(df_3, hue="diabetes")

"""## Détecter ou la supprime les valeurs abérantes

#Catégorisé les bmi
"""

'''weight_categories = pd.Series(["Underweight","Normal", "Overweight","Obesity 1", "Obesity 2", "Obesity 3"], dtype = "category")
weight_categories'''

'''df_3['weight_categories'] = weight_categories
df_3.loc[(df_3["bmi"] < 18.5), "weight_categories"] = weight_categories[0]
df_3.loc[(df_3["bmi"] >= 18.5) & (df_3["bmi"] <= 24.9), "weight_categories"] = weight_categories[1]
df_3.loc[(df_3["bmi"] > 24.9) & (df_3["bmi"] <= 29.9), "weight_categories"] = weight_categories[2]
df_3.loc[(df_3["bmi"] > 29.9) & (df_3["bmi"] <= 34.9), "weight_categories"] = weight_categories[3]
df_3.loc[(df_3["bmi"] > 34.9) & (df_3["bmi"] <= 39.9), "weight_categories"] = weight_categories[4]
df_3.loc[df_3["bmi"] > 39.9, "weight_categories"] = weight_categories[5]
df_3.loc[df_3["bmi"]<= 18]
##
col = 'weight_categories'
colonnes = list(df_3.columns)
colonnes.remove(col)
# Insérer à la 6 ème position (index 2)
colonnes.insert(6, col)
df_3 = df_3[colonnes]
df_3'''

df_3.groupby("diabetes").agg({'blood_glucose_level':'mean'})

df_3.head()
df_3.describe()

'''f,ax = plt.subplots(1,2, figsize=(18,8))
df_3['diabetes'].value_counts().plot.pie(explode=[0,0.1],autopct = "%1.1f%%", ax=ax[0], shadow=True)
ax[0].set_title('target')
ax[0].set_ylabel('')
sns.countplot('diabetes', data=df_3, ax=ax[1])
ax[1].set_title('diabetes')
plt.show()'''

'''from scipy import stats

import numpy as np

df_4 = df_3[(np.abs(stats.zscore(df_3[['age','bmi',"HbA1c_level","blood_glucose_level"]])) < 3).all(axis=1)]
df_4.head()
df_4.describe()'''

'''import matplotlib.pyplot as plt

colonnes_a_afficher = ['age', 'bmi', 'HbA1c_level', 'blood_glucose_level']  # Remplace par les noms de tes colonnes

for colonne in colonnes_a_afficher:
    df_4[[colonne]].boxplot()
    plt.title(f"Boxplot de la colonne {colonne}")
    plt.show()'''

df_3.isnull().sum()
df_3.describe()

#df_4.describe()

"""# Normalistation"""

'''from sklearn.preprocessing import StandardScaler

cols = ["HbA1c_level", "blood_glucose_level"]

scaler = StandardScaler()

df_3[cols] = scaler.fit_transform(df_3[cols])
df_3[df_3['diabetes']==1]'''

"""# Model de régression"""

from sklearn import preprocessing

# Scale and plot the features against diabetes (target) using the MinMax scaler (Normalization)
min_max_scaler = preprocessing.MinMaxScaler()
col_name = df_3.drop('diabetes', axis = 1).columns[:]
x = df_3.loc[:, col_name]
y = df_3['diabetes']

x

y

"""# Régression linéaire"""

fig, axs = plt.subplots(ncols = 3, nrows = 3, figsize = (20, 20))
sns.regplot(y = df_3['diabetes'], x = x['gender'], ax = axs[0, 0])
sns.regplot(y = df_3['diabetes'], x = x['age'], ax = axs[0, 1])
sns.regplot(y = df_3['diabetes'], x = x['hypertension'], ax = axs[0, 2])
sns.regplot(y = df_3['diabetes'], x = x['heart_disease'], ax = axs[1, 0])
sns.regplot(y = df_3['diabetes'], x = x['smoking_history'], ax = axs[1, 1])
sns.regplot(y = df_3['diabetes'], x = x['bmi'], ax = axs[1, 2])
sns.regplot(y = df_3['diabetes'], x = x['HbA1c_level'], ax = axs[2, 0])
sns.regplot(y = df_3['diabetes'], x = x['blood_glucose_level'], ax = axs[2, 1])
plt.tight_layout()

"""#Building the model"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train , y_test = train_test_split(x,y, test_size=0.2, random_state=42)

X_train

X_test

"""# LogisticRegression"""

from sklearn.preprocessing import RobustScaler
from sklearn.linear_model import LogisticRegression
log_reg = LogisticRegression()
log_reg.fit(X_train, y_train)

from sklearn.metrics import confusion_matrix, accuracy_score, mean_squared_error, r2_score, roc_auc_score, roc_curve, classification_report

y_pred = log_reg.predict(X_test)
accuracy_score(y_train, log_reg.predict(X_train))

log_reg_acc = accuracy_score(y_test, log_reg.predict(X_test))
log_reg_acc

confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))

"""#Random Forest"""

from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier

rand_clf = RandomForestClassifier(criterion = 'entropy', max_depth = 15, max_features = 0.75, min_samples_leaf = 2, min_samples_split = 3, n_estimators = 130)
rand_clf.fit(X_train, y_train)

y_pred = rand_clf.predict(X_test)

y_pred = rand_clf.predict(X_test)
print(accuracy_score(y_train, rand_clf.predict(X_train)))
rand_acc = accuracy_score(y_test, rand_clf.predict(X_test))
print(accuracy_score(y_test, rand_clf.predict(X_test)))
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

"""#Comparaison des performances des modèles"""

import matplotlib.pyplot as plt
models = [
{
    'label': 'LR',
    'model': log_reg,
},

{
    'label': 'RF',
    'model': rand_clf,
}
]

means_roc = []
means_accuracy = [100*round(log_reg_acc,4),
                  100*round(rand_acc,4)]

from sklearn import metrics
for m in models:
    model = m['model']
    model.fit(X_train, y_train)
    y_pred=model.predict(X_test)
    fpr1, tpr1, thresholds = metrics.roc_curve(y_test, model.predict_proba(X_test)[:,1])
    auc = metrics.roc_auc_score(y_test,model.predict(X_test))
    auc = 100*round(auc,4)
    means_roc.append(auc)
print(means_accuracy)
print(means_roc)

n_groups = 2
means_accuracy = tuple(means_accuracy)
means_roc = tuple(means_roc)

'''fig, ax = plt.subplots(figsize=(8,5))
index = np.arange(n_groups)
bar_width = 0.35
opacity = 0.8

rects1 = plt.bar(index, means_accuracy, bar_width,
alpha=opacity,
color='mediumpurple',
label='Accuracy (%)')

rects2 = plt.bar(index + bar_width, means_roc, bar_width,
alpha=opacity,
color='rebeccapurple',
label='ROC (%)')

plt.xlim([-1, 8])
plt.ylim([60, 95])

plt.title('Performance Evaluation - Diabetes Prediction', fontsize=12)
plt.xticks(index, ('   LR', 'RF'), rotation=40, ha='center', fontsize=12)
plt.legend(loc="upper right", fontsize=10)
plt.savefig("PE_diabetes.jpeg", format='jpeg', dpi=400, bbox_inches='tight')
plt.show()'''

from sklearn import metrics
import numpy as np
import matplotlib.pyplot as plt

# Liste de modèles réduite
models = [
    {
        'label': 'LR',
        'model': log_reg,
    },
    {
        'label': 'RF',
        'model': rand_clf,
    }
]

means_roc = []
means_accuracy = [100*round(log_reg_acc, 4), 100*round(rand_acc, 4)]

for m in models:
    model = m['model']
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    fpr1, tpr1, thresholds = metrics.roc_curve(y_test, model.predict_proba(X_test)[:, 1])
    auc = metrics.roc_auc_score(y_test, model.predict(X_test))
    auc = 100*round(auc, 4)
    means_roc.append(auc)

print(means_accuracy)
print(means_roc)

# Affichage du barplot pour 2 modèles
n_groups = 2
means_accuracy = tuple(means_accuracy)
means_roc = tuple(means_roc)

fig, ax = plt.subplots(figsize=(5,5))
index = np.arange(n_groups)
bar_width = 0.35
opacity = 0.8

rects1 = plt.bar(index, means_accuracy, bar_width,
                 alpha=opacity,
                 color='mediumpurple',
                 label='Accuracy (%)')

rects2 = plt.bar(index + bar_width, means_roc, bar_width,
                 alpha=opacity,
                 color='rebeccapurple',
                 label='ROC (%)')

plt.xlim([-1, 2])
plt.ylim([0, 100])

plt.title('Performance Evaluation - Diabetes Prediction', fontsize=12)
plt.xticks(index, ('LR', 'RF'), rotation=0, ha='center', fontsize=12)
plt.legend(loc="upper right", fontsize=10)
plt.savefig("PE_diabetes_LR_RF.jpeg", format='jpeg', dpi=400, bbox_inches='tight')
plt.show()